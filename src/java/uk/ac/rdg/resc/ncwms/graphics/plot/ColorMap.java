/*
 * Copyright (c) 2008 The University of Reading
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University of Reading, nor the names of the
 *    authors or contributors may be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package uk.ac.rdg.resc.ncwms.graphics.plot;

import java.awt.Color;
import java.awt.image.IndexColorModel;

/**
 * A color map holds a color scheme and a scale transform to provide a mapping
 * from real data values to colors. The scale transform is specified by:
 *   - A range of inner values in the original data scale.
 *   - A boolean flag storing if the scale of the data is linear or logarithmic.
 * The color scheme is made of:
 *   - A color for undefined values.
 *   - A color for values above the maximum value in the scale range.
 *   - A color for values below the minimum value in the scale range.
 *   - A sequence of colors for in range data generated by interpolation
 *     of a color palette onto a given number of bands.
 */
public class ColorMap
{
    /**
     * The maximum number of colors a color map can support (253).
     * (One would be hard pushed to distinguish more colors than this in a
     * typical scenario anyway.)
     */
    public static final int MAX_NUM_COLORS = 253;
    
    private Color[] palette = null;
    private int numColorBands = MAX_NUM_COLORS;
    private Color undefValColor = new Color(0, 0, 0, 0);
    private Color belowMinColor = new Color(0, 0, 0, 0);
    private Color aboveMaxColor = new Color(0, 0, 0, 0);
    boolean transparent = true;
    boolean extendBelow = true;
    boolean extendAbove = true;
    private float opacity = 1.0f;
    private double minValue = 0.0;
    private double maxValue = 1.0;
    private boolean logScale = false;
    
    private double offset;
    private double extent;
    private Color[] colors;
    private int undefValColorIndex;
    private int belowMinColorIndex;
    private int aboveMaxColorIndex;
    
    private IndexColorModel colorModel;
    
    /**
     * Create a new color map with default color scheme and default scale.
     * 
     * The default color scheme uses the the default palette, the maximum number
     * of colors allowed, transparent color for undefined values, and extended
     * colors below and above the scale range.
     * 
     * The default scale is linear and the default range is `[0, 1]`.
     */
    public ColorMap()
    {
        updateColors();
        updateScale();
    }
    
    
    /**
     * Create a new color map with given color scheme and default scale.
     * 
     * See default constructor for a description of the default scale.
     * 
     * @param palette palette to use.
     * @param numColorBands number of color bands in scale range
     * @param undefValColor color for undefined (background or invalid) values.
     * @param belowMinColor color for values below minimum value in scale range.
     * @param aboveMaxColor color for values above maximum value in scale range.
     * @param transparent use a fully transparent black color for undefined values.
     * @param extendBelow use lowest palette color for values below minimum scale value.
     * @param extendAbove use highest palette color for values above maximum scale value.
     * @param opacity alpha channel factor to apply to each color.
     */
    public ColorMap(Color[] palette, int numColorBands,
                    Color undefValColor, Color belowMinColor, Color aboveMaxColor,
                    boolean transparent, boolean extendBelow, boolean extendAbove,
                    float opacity)
    {
        setColors(palette, numColorBands,
                  undefValColor, belowMinColor, aboveMaxColor,
                  transparent, extendBelow, extendAbove, opacity);
        updateScale();
    }
    
    
    /**
     * Create a new color map with default color scheme and given scale.
     * 
     * See default constructor for a description of the default color scheme.
     * 
     * @param minValue value to map to the lowest color in the color map.
     * @param maxValue value to map to the highest color in the color map.
     * @param logScale whether the scale is logarithmic.
     */
    public ColorMap(double minValue, double maxValue, boolean logScale)
    {
        updateColors();
        setScale(minValue, maxValue, logScale);
    }
    
    
    /**
     * Create a new color map with given color scheme and given scale.
     * 
     * @param palette palette to use.
     * @param numColorBands number of color bands in scale range
     * @param undefValColor color for undefined (background or invalid) values.
     * @param belowMinColor color for values below minimum value in scale range.
     * @param aboveMaxColor color for values above maximum value in scale range.
     * @param transparent use a fully transparent black color for undefined values.
     * @param extendBelow use lowest palette color for values below minimum scale value.
     * @param extendAbove use highest palette color for values above maximum scale value.
     * @param opacity alpha channel factor to apply to each color.
     * @param minValue value to map to the lowest color in the color map.
     * @param maxValue value to map to the highest color in the color map.
     * @param logScale whether the scale is logarithmic.
     */
    public ColorMap(Color[] palette, int numColorBands,
                    Color undefValColor, Color belowMinColor, Color aboveMaxColor,
                    boolean transparent, boolean extendBelow, boolean extendAbove,
                    float opacity, 
                    double minValue, double maxValue, boolean logScale)
    {
        setColors(palette, numColorBands,
                  undefValColor, belowMinColor, aboveMaxColor,
                  transparent, extendBelow, extendAbove, opacity);
        setScale(minValue, maxValue, logScale);
    }
    
    
    /**
     * Update the color scheme used by the color map
     * 
     * @param palette palette to use.
     * @param numColorBands number of color bands in scale range
     * @param undefValColor color for undefined (background or invalid) values.
     * @param belowMinColor color for values below minimum value in scale range.
     * @param aboveMaxColor color for values above maximum value in scale range.
     * @param transparent use a fully transparent black color for undefined values.
     * @param extendBelow use lowest palette color for values below minimum scale value.
     * @param extendAbove use highest palette color for values above maximum scale value.
     * @param opacity alpha channel factor to apply to each color.
     */
    public void setColors(Color palette[], int numColorBands,
                          Color undefValColor, Color belowMinColor, Color aboveMaxColor,
                          boolean transparent, boolean extendBelow, boolean extendAbove, float opacity)
    {
        if (numColorBands < 1 || numColorBands > MAX_NUM_COLORS)
            throw new IllegalArgumentException("number of color bands must be between 1 and " + MAX_NUM_COLORS);
        this.numColorBands = numColorBands;
        this.palette = palette;
        this.undefValColor = undefValColor;
        this.belowMinColor = belowMinColor;
        this.aboveMaxColor = aboveMaxColor;
        this.transparent = transparent;
        this.extendBelow = extendBelow;
        this.extendAbove = extendAbove;
        this.opacity = opacity;
        updateColors();
    }
    
    
    /**
     * Update the scale to use.
     * 
     * @param minValue value to map to the lowest color in the color map.
     * @param maxValue value to map to the highest color in the color map.
     * @param logScale whether the scale is logarithmic or linear.
     */
    public void setScale(double minValue, double maxValue, boolean logScale)
    {
        this.minValue = minValue;
        this.maxValue = maxValue;
        this.logScale = logScale;
        updateScale();
    }
    
    
    /**
     * Update the range of the scale (preserving the scale type).
     * 
     * @param minValue value to map to the lowest color in the color map.
     * @param maxValue value to map to the highest color in the color map.
     */
    public void setScaleRange(double minValue, double maxValue)
    {
        this.minValue = minValue;
        this.maxValue = maxValue;
        updateScale();
    }
    
    /**
     * Update the type of the scale (preserving the range).
     * 
     * Note that this may leave an invalid scale when the current range
     * includes non-positive values. Update both the type and the range of the
     * scale with setScale in that case.
     * 
     * @param logScale whether the scale is logarithmic or linear.
     */
    public void setScaleType(boolean logScale)
    {
        this.logScale = logScale;
        updateScale();
    }
    
    
    /**
     * Get the number of color bands covering the color scale range.
     * @return the number of color bands for the scale range.
     */
    public int getNumColorBands()
    {
        return numColorBands;
    }
    
    
    /**
     * Get the number of colors in the color map.
     * 
     * This can be the number of bands plus 1, 2 or 3, depending on the color
     * color choice for low, high and undefined values and the extend toggles.
     * 
     * @return the number of total number of colors.
     */
    public int getSize()
    {
        return colors.length;
    }
    
    
    /**
     * Get the minimum value in the scale range.
     * 
     * @return the maximum value in the scale range.
     */
    public double getScaleMin()
    {
        return minValue;
    }
    
    
    /**
     * Get the maximum value in the scale range.
     * 
     * @return the maximum value in the scale range.
     */
    public double getScaleMax()
    {
        return maxValue;
    }
    
    
    /**
     * Get the color for undefined values ignoring transparency.
     * 
     * @return the color for undefined values.
     */
    public Color getUndefValColor()
    {
        return undefValColor;
    }
    
    
    /**
     * Get the color for values below the minimum value in the range ignoring extension.
     * 
     * @return the color for values below the minimum value in the range.
     */
    public Color getBelowMinColor()
    {
        return belowMinColor;
    }
    
    
    /**
     * Get the color for values above the maximum value in the range ignoring extension.
     * 
     * @return the color for values above the maximum value in the range.
     */
    public Color getAboveMaxColor()
    {
        return aboveMaxColor;
    }
    
    
    /**
     * Get the index of the color corresponding to a value.
     * 
     * Return -1 if no color for undefined values is set and 
     * the input value is invalid (NaN) or lies outside the scale range
     * and the color map is not extended.
     * 
     * @param value value to map.
     * @return index of the color in the color map the value maps to, or -1.
     */
    public int getColorIndex(double value)
    {
        int i = undefValColorIndex;
        double v = logScale ? Math.log(value) : value;
        if (! Double.isNaN(v))
        {
            v -= offset;
            v /= extent;
            if (v < 0.0f)
                i = belowMinColorIndex;
            else if (v > 1.0f)
                i = aboveMaxColorIndex;
            else if (v == 1.0f)
                i = numColorBands - 1;
            else
                i = (int) (v * numColorBands); // cast truncates (rounds toward 0)
        }
        return i;
    }
    
    
    /**
     * Get the color corresponding to a value.
     * 
     * Return null if there is no color defined for the given value.
     * 
     * @param value value to map.
     * @return color corresponding to the given value or null.
     */
    public Color getColorValue(double value)
    {
        int i = getColorIndex(value);
        return (i < 0) ? null : colors[i];
    }
    
    
    /**
     * Get a color in the color model associated to this color map by its index.
     * 
     * If the index is less than the number of color bands requested, the index
     * points to the corresponding color in the interpolated palette.
     * This method should not be called with other index values. It may throw
     * an exception or return some other color involved in the color map.
     * 
     * @param index index of the color to get.
     * @return the color at given index in the associated color model.
     */
    public Color getIndexedColor(int index)
    {
        return colors[index];
    }
    
    
    /**
     * Get the value in the scale range that map to an index in the color model
     * associated to this color map.
     * 
     * For values in range [0, numColorBands], this is the inverse of the
     * mapping defined by getColorIndex. So it returns the value in the scale
     * range corresponding to a given color in the palette.
     * The mapping is extended to non-integral numbers.
     * If the given index matches the index of the color for undefined values,
     * NaN is returned. Else if the index matches the index of the color for
     * values below or above the scale range, -Inf or Inf is returned.
     * 
     * @param index (continuous) index in the (extended) palette.
     * @return a value in the scale that maps to that index, or NaN.
     */
    public double getContinuousIndexedValue(double index)
    {
        double v;
        if (0 <= index && index <= numColorBands)
            v = offset + extent * (index / numColorBands);
        else if (index == undefValColorIndex)
            v = Double.NaN;
        else if (index == belowMinColorIndex)
            v = Double.NEGATIVE_INFINITY;
        else if (index == aboveMaxColorIndex)
            v = Double.POSITIVE_INFINITY;
        else
            v = Double.NaN;
        return logScale ? Math.exp(v) : v;
    }
    
    
    /**
     * Update the internal list of colors and extended color indices.
     */
    private void updateColors()
    {
        int size = numColorBands;
        if (undefValColor == null && ! transparent)
            undefValColorIndex = -1;
        else
            undefValColorIndex = size++;
        if (extendBelow)
            belowMinColorIndex = 0;
        else if (belowMinColor == null)
            belowMinColorIndex = undefValColorIndex;
        else
            belowMinColorIndex = size++;
        if (extendAbove)
            aboveMaxColorIndex = numColorBands;
        else if (aboveMaxColor == null)
            aboveMaxColorIndex = undefValColorIndex;
        else
            aboveMaxColorIndex = size++;

        if (colors == null || colors.length != size)
            colors = new Color[size];
        int numPaletteBands = palette.length;
        if (numPaletteBands > 1 && numColorBands > 1)
            for (int colorIndex = 0; colorIndex < numColorBands; colorIndex++)
            {
                double c = 1.0f / (numColorBands - 1.0f) * colorIndex;
                int paletteIndex = (int) Math.floor(c * (numPaletteBands - 1.0f));
                double p = c * (numPaletteBands - 1.0f) - paletteIndex;
                if (p == 0.0f) {
                    Color curr = palette[paletteIndex];
                    colors[colorIndex] = new Color(
                            curr.getRed(), curr.getGreen(), curr.getBlue(),
                            (int) Math.round(curr.getAlpha() * opacity));
                } else {
                    Color prev = palette[paletteIndex];
                    Color next = palette[paletteIndex + 1];
                    colors[colorIndex] = new Color(
                            (int) Math.round( (1.f - p) * prev.getRed()   + p * next.getRed()),
                            (int) Math.round( (1.f - p) * prev.getGreen() + p * next.getGreen()),
                            (int) Math.round( (1.f - p) * prev.getBlue()  + p * next.getBlue()),
                            (int) Math.round(((1.f - p) * prev.getAlpha() + p * next.getAlpha()) * opacity));
                }
            }
        else
            for (int colorIndex = 0; colorIndex < numColorBands; colorIndex++)
                colors[colorIndex] = palette[0];
        if (undefValColor != null)
            colors[undefValColorIndex] = new Color(
                    undefValColor.getRed(), undefValColor.getGreen(), undefValColor.getBlue(),
                    (transparent ? 0 : 1) * (int) Math.round(opacity * undefValColor.getAlpha()));
        else if (transparent)
            colors[undefValColorIndex] = new Color(0, 0, 0, 0);
        if (belowMinColor != null && ! extendBelow)
            colors[belowMinColorIndex] = new Color(
                    belowMinColor.getRed(), belowMinColor.getGreen(), belowMinColor.getBlue(),
                    (int) Math.round(opacity * belowMinColor.getAlpha()));
        if (aboveMaxColor != null && ! extendAbove)
            colors[aboveMaxColorIndex] = new Color(
                    aboveMaxColor.getRed(), aboveMaxColor.getGreen(), aboveMaxColor.getBlue(),
                    (int) Math.round(opacity * aboveMaxColor.getAlpha()));
        
        colorModel = null;
    }
    
    
    /**
     * Update the internal parameters of the scale transform.
     */
    private void updateScale()
    {
        if (logScale)
        {
            offset = Math.log(minValue);
            extent = Math.log(maxValue) - Math.log(minValue);
        }
        else
        {
            offset = minValue;
            extent = maxValue - minValue;
        }
    }
    
    
    /**
     * Update the internal cached color model.
     */
    private void updateColorModel()
    {
        int length = colors.length;
        byte[] r = new byte[length];
        byte[] g = new byte[length];
        byte[] b = new byte[length];
        byte[] a = new byte[length];
        for (int i = 0; i < length; i++)
        {
            Color color = colors[i];
            r[i] = (byte) color.getRed();
            g[i] = (byte) color.getGreen();
            b[i] = (byte) color.getBlue();
            a[i] = (byte) color.getAlpha();
        }
        colorModel = new IndexColorModel(8, length, r, g, b, a);
    }
    
    
    /**
     * Get the indexed color model based on this color map.
     * @return a 8-bit indexed color model with the colors in the color map.
     */
    public IndexColorModel getColorModel()
    {
        if (colorModel == null)
            updateColorModel();
        return colorModel;
    }
    
    
    /**
     * Get the color used for undefined values.
     * 
     * The returned color is:
     *   - The color choice for undefined values affected by opacity, if any and not transparent.
     *   - The color choice for undefined values set to transparent, if any and transparent.
     *   - A black transparent color, if no color choice and transparent.
     *   - null otherwise.
     *   
     * @return the undefinded value color (or null if not defined).
     */
    public Color getExtendedUndefValColor() 
    {
        return undefValColorIndex < 0 ? null : colors[undefValColorIndex];
    }
    
    
    /**
     * Get the color used for values below the minimum value in the range.
     * 
     * The returned color is:
     *   - The first color in the palette, when the mapping is extended below.
     *   - The color choice for low values affected by opacity, if any.
     *   - The undefined value color (if defined) or null, otherwise
     *   
     * @return the low value color used in the mapping.
     */
    public Color getExtendedBelowMinColor()
    {
        return belowMinColorIndex < 0 ? null : colors[belowMinColorIndex];
    }
    
    
    /**
     * Get the color used for values above the maximum value in the range.
     * 
     * The returned color is:
     *   - The last color in the palette, when the mapping is extended above.
     *   - The color chosen for high values affected by opacity, if any.
     *   - The undefined value color (if defined) or null, otherwise
     *   
     * @return the high value color used in the mapping.
     */
    public Color getExtendedAboveMaxColor()
    {
        return aboveMaxColorIndex < 0 ? null : colors[aboveMaxColorIndex];
    }

}
